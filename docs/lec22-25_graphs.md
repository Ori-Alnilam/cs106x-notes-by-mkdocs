# Lec22-25_Graphs
!!! note
    DFS会向深处递归，BFS将当前节点的neighbors放入队列中，一层一层往下遍历，因此能得到**无权图**中一个节点到其他节点的**最短路径**。但如果路径带权，BFS无法得到实际上的最短路径......

    **Dijkstra算法**解决在**加权图**中的最短路径问题。使用的是**优先队列**。

    无权图中，Dijkstra算法基本上和BFS相同。无权图可以视为所有边的权重都相同（比如都为0或1），Dijkstra找到的权重最小的路径实际上就是长度最小的路径（BFS）

    Dijkstra很好，但它是向各个方向探索路径，如果我们搜索路径时明确目标方向呢？（如目标点在东）

    **A\*算法**基于Dijkstra算法，在路径探索优先级的计算中加上**启发式**成本：
    $$a - -b - -c$$
    $$priority (b) = cost (a, b) + Heuristic (b, c)$$
    优先探索那些估计总成本更低的路径。

    **最小生成树**：在一个带权连通无向图中，找到一棵包含所有顶点且边权之和最小的树

    **Kruskal算法**：

    **拓扑排序**：
    - 在有向无环图（DAG）中，对于图中的任意一条有向边`(u, v)`，顶点`u`在排序中都出现在顶点`v`之前。
    - 结合“课程先修要求”的例子理解。
    - **有向无环**图里必然存在一些入度为 0 的顶点，这些顶点没有前驱节点，可以作为排序的起始点。
    - 拓扑排序表示的是顶点之间的依赖关系。

---

